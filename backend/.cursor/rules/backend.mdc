---
alwaysApply: true
---

# Backend Project Rules

## Project Overview

This backend API uses:
- **Runtime**: Bun (latest)
- **Framework**: Elysia (latest)
- **Database**: PostgreSQL with `postgres` library
- **Language**: TypeScript (strict mode, ES2021 target, ES2022 modules)
- **Architecture**: MVC (Model-View-Controller) pattern

## Project Structure

```
src/
├── config/          # Application and database configuration
├── controllers/     # HTTP request handlers (thin layer)
├── db/             # Database connection, migrations, utilities
├── middleware/     # Global middleware (error handling, logging)
├── models/         # TypeScript interfaces, DTOs, base models
├── routes/         # Route definitions and registration
├── services/       # Business logic layer (database operations)
├── views/          # Response formatting (presentation layer)
└── index.ts        # Application entry point
```

## Architecture: MVC Pattern

### Models (`models/`)

**DO:**
- Define data structures, interfaces, and DTOs
- Extend `BaseModel` interface for all domain models
- Create separate DTOs for Create and Update operations
- Use interfaces, not types, for models
- Export all types from model files

**Example:**
```typescript
import { BaseModel } from "./base.model";

export interface Example extends BaseModel {
  name: string;
  description?: string;
  status: "active" | "inactive";
}

export interface CreateExampleDto {
  name: string;
  description?: string;
  status?: "active" | "inactive";
}

export interface UpdateExampleDto {
  name?: string;
  description?: string;
  status?: "active" | "inactive";
}
```

### Views (`views/`)

**DO:**
- Use `ResponseView` class for ALL API responses
- Use `ResponseView.success()` for successful responses
- Use `ResponseView.error()` for error responses
- Use `ResponseView.paginated()` for paginated lists
- Always return `ApiResponse<T>` type

**DON'T:**
- Return raw data without `ResponseView`
- Create custom response formats

**Example:**
```typescript
// Success
return ResponseView.success(data, "Optional message");

// Error
return ResponseView.error("Error message", "Optional details");

// Paginated
return ResponseView.paginated(items, page, limit, total, "Optional message");
```

### Controllers (`controllers/`)

**DO:**
- Keep controllers thin - only HTTP concerns
- Validate input data in controllers
- Call services for business logic
- Use `ResponseView` to format responses
- Set appropriate HTTP status codes using `set.status`
- Handle service null returns with 404 status
- Use try-catch for service calls that might throw

**DON'T:**
- Put business logic in controllers
- Access database directly from controllers
- Return raw service responses

**Example:**
```typescript
export const exampleController = new Elysia({ prefix: "/examples" })
  .get("/", async () => {
    const examples = await exampleService.findAll();
    return ResponseView.success(examples, "Examples retrieved successfully");
  })

  .get("/:id", async ({ params, set }) => {
    const example = await exampleService.findById(params.id);
    
    if (!example) {
      set.status = 404;
      return ResponseView.error("Example not found");
    }

    return ResponseView.success(example, "Example retrieved successfully");
  })

  .post("/", async ({ body, set }) => {
    try {
      const data = body as CreateExampleDto;
      
      if (!data.name || data.name.trim() === "") {
        set.status = 400;
        return ResponseView.error("Name is required");
      }

      const example = await exampleService.create(data);
      set.status = 201;
      return ResponseView.success(example, "Example created successfully");
    } catch (error) {
      set.status = 500;
      return ResponseView.error(
        "Failed to create example",
        error instanceof Error ? error.message : "Unknown error"
      );
    }
  });
```

### Services (`services/`)

**DO:**
- Put ALL business logic in services
- Put ALL database operations in services
- Return domain models, not DTOs
- Return `null` for "not found" cases (don't throw)
- Use `getDb()` for database access
- Map snake_case database columns to camelCase TypeScript properties
- Use `AS` aliases in SELECT: `created_at as "createdAt"`

**DON'T:**
- Access HTTP context in services
- Throw errors for "not found" cases
- Return DTOs from services

**Example:**
```typescript
import { getDb } from "../db/connection";
import { Example, CreateExampleDto, UpdateExampleDto } from "../models/example.model";

class ExampleService {
  async findAll(): Promise<Example[]> {
    const db = getDb();
    const results = await db<Example[]>`
      SELECT 
        id,
        name,
        description,
        status,
        created_at as "createdAt",
        updated_at as "updatedAt"
      FROM examples
      ORDER BY created_at DESC
    `;
    return results;
  }

  async findById(id: string | number): Promise<Example | null> {
    const db = getDb();
    const results = await db<Example[]>`
      SELECT 
        id,
        name,
        description,
        status,
        created_at as "createdAt",
        updated_at as "updatedAt"
      FROM examples
      WHERE id = ${id}
      LIMIT 1
    `;
    return results[0] || null;
  }

  async create(data: CreateExampleDto): Promise<Example> {
    const db = getDb();
    const results = await db<Example[]>`
      INSERT INTO examples (name, description, status)
      VALUES (${data.name}, ${data.description || null}, ${data.status || "active"})
      RETURNING 
        id,
        name,
        description,
        status,
        created_at as "createdAt",
        updated_at as "updatedAt"
    `;
    return results[0];
  }
}

export const exampleService = new ExampleService();
```

### Routes (`routes/`)

**DO:**
- Use Elysia with API prefix from `appConfig.apiPrefix`
- Register controllers using `.use()`
- Define route-level endpoints if needed

**Example:**
```typescript
import { Elysia } from "elysia";
import { exampleController } from "../controllers/example.controller";
import { appConfig } from "../config/app.config";

export const routes = new Elysia({ prefix: appConfig.apiPrefix })
  .use(exampleController)
  .get("/health", () => ({
    success: true,
    message: "Server is healthy",
    timestamp: new Date().toISOString(),
  }));
```

### Middleware (`middleware/`)

**DO:**
- Apply middleware globally in `index.ts`
- Handle errors in error middleware
- Log requests in logger middleware

## Code Style & Conventions

### TypeScript

**DO:**
- Use strict mode (enabled in tsconfig.json)
- Target ES2021, Module ES2022
- Always use explicit types for function parameters and return values
- Prefer interfaces over types for models
- Use `as const` for configuration objects
- Use `unknown` instead of `any` when type is truly unknown

**DON'T:**
- Use `any` type
- Omit type annotations for function parameters/returns
- Use types instead of interfaces for models

### Naming Conventions

**Files**: kebab-case
- `example.controller.ts`
- `error.middleware.ts`
- `example.service.ts`

**Classes**: PascalCase
- `ExampleService`
- `ResponseView`

**Interfaces**: PascalCase
- `Example`
- `BaseModel`
- `CreateExampleDto`
- `UpdateExampleDto`

**Functions/Variables**: camelCase
- `findById`
- `exampleService`
- `getDb`

**Constants**: camelCase with `as const`
- `appConfig`
- `dbConfig`

**Database tables**: snake_case
- `examples`
- `folders`
- `files`

**Database columns**: snake_case
- `parent_id`
- `created_at`
- `updated_at`

### Imports

**DO:**
- Use ES module imports (`import`/`export`)
- Group imports: external libraries first, then internal modules
- Use relative imports from `src/` root

**Example:**
```typescript
import { Elysia } from "elysia";
import { exampleService } from "../services/example.service";
import { ResponseView } from "../views/response.view";
import { CreateExampleDto } from "../models/example.model";
```

## Database Patterns

### Connection

**DO:**
- Use singleton pattern via `getDb()` from `db/connection.ts`
- Connection is lazy-initialized on first call
- Always close connection on graceful shutdown
- Test connection on server startup

**Example:**
```typescript
import { getDb } from "../db/connection";

const db = getDb();
```

### Queries

**DO:**
- Use tagged template literals for SQL queries (prevents SQL injection)
- For dynamic queries, use `db.unsafe()` with parameterized queries
- Always map snake_case columns to camelCase in TypeScript interfaces
- Use `AS` aliases in SELECT statements

**DON'T:**
- Use string concatenation for SQL queries
- Use `db.unsafe()` without parameters

**Examples:**
```typescript
// ✅ Good: Tagged template literal
const results = await db<Example[]>`
  SELECT id, name, created_at as "createdAt"
  FROM examples
  WHERE id = ${id}
`;

// ✅ Good: Parameterized unsafe query for dynamic updates
const query = `UPDATE examples SET ${updates.join(", ")} WHERE id = $${values.length}`;
const results = await db.unsafe<Example[]>(query, values);

// ❌ Bad: String concatenation (SQL injection risk)
const query = `SELECT * FROM examples WHERE id = ${id}`;
```

### Migrations

**DO:**
- Number migration files sequentially (001_, 002_, etc.)
- Use `IF NOT EXISTS` for idempotency
- Always test migrations on development first
- Use transactions for migration execution
- Include timestamp and comments in migration template

**DON'T:**
- Modify already-applied migrations
- Create migrations without testing

**Migration Template:**
```sql
-- Migration: migration_name
-- Created: 2024-01-01T00:00:00.000Z

CREATE TABLE IF NOT EXISTS your_table (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

### Service Update Pattern

**DO:**
- Check existence first
- Build dynamic update query with parameters
- Return null if not found

**Example:**
```typescript
async update(id: string | number, data: UpdateExampleDto): Promise<Example | null> {
  const db = getDb();
  
  const existing = await this.findById(id);
  if (!existing) {
    return null;
  }

  const updates: string[] = [];
  const values: unknown[] = [];

  if (data.name !== undefined) {
    updates.push(`name = $${values.length + 1}`);
    values.push(data.name);
  }
  if (data.description !== undefined) {
    updates.push(`description = $${values.length + 1}`);
    values.push(data.description);
  }
  if (data.status !== undefined) {
    updates.push(`status = $${values.length + 1}`);
    values.push(data.status);
  }

  if (updates.length === 0) {
    return existing;
  }

  values.push(id);
  const query = `
    UPDATE examples
    SET ${updates.join(", ")}, updated_at = CURRENT_TIMESTAMP
    WHERE id = $${values.length}
    RETURNING 
      id,
      name,
      description,
      status,
      created_at as "createdAt",
      updated_at as "updatedAt"
  `;

  const results = await db.unsafe<Example[]>(query, values);
  return results[0] || null;
}
```

## API Patterns

### Response Format

**ALWAYS** use `ResponseView` for consistent responses:

```typescript
// Success response
ResponseView.success(data, "Optional message")

// Error response
ResponseView.error("Error message", "Optional error details")

// Paginated response
ResponseView.paginated(items, page, limit, total, "Optional message")
```

### HTTP Status Codes

- `200`: Success (GET, PUT)
- `201`: Created (POST)
- `400`: Bad Request (validation errors)
- `404`: Not Found (resource not found)
- `500`: Internal Server Error (server errors)

**DO:**
- Set status codes using `set.status` in controllers
- Use 201 for successful POST requests
- Use 404 when service returns null
- Use 400 for validation errors
- Use 500 for unexpected server errors

## Error Handling

### Middleware

**DO:**
- Let global error middleware handle all errors
- Map Elysia error codes to HTTP status codes:
  - `NOT_FOUND` → 404
  - `VALIDATION` → 400
  - `INTERNAL_SERVER_ERROR` → 500
- Show full error messages in development
- Hide sensitive error details in production

### Service Layer

**DO:**
- Return `null` for "not found" cases (don't throw)
- Let controllers handle HTTP status codes
- Throw errors only for unexpected failures (caught by middleware)

**DON'T:**
- Throw errors for "not found" cases
- Set HTTP status codes in services

### Controller Layer

**DO:**
- Validate input data in controllers
- Handle service null returns with 404 status
- Use try-catch for service calls that might throw
- Always set appropriate HTTP status codes

## Configuration

### App Config (`config/app.config.ts`)

**DO:**
- Use environment variables with defaults
- Export `as const` for type safety
- Properties: `port`, `host`, `env`, `apiPrefix`

**Example:**
```typescript
export const appConfig = {
  port: process.env.PORT || 3000,
  host: process.env.HOST || "0.0.0.0",
  env: process.env.NODE_ENV || "development",
  apiPrefix: "/api/v1",
} as const;
```

### Database Config (`config/db.config.ts`)

**DO:**
- Configure connection pooling settings
- Use `getDatabaseUrl()` function to read `DATABASE_URL` env var
- Properties: `max`, `idleTimeoutMillis`, `connectionTimeoutMillis`

### Environment Variables

- `PORT`: Server port (default: 3000)
- `HOST`: Server hostname (default: "0.0.0.0")
- `NODE_ENV`: Environment (development/production)
- `DATABASE_URL`: PostgreSQL connection string (required)

## Adding New Features

### Step-by-Step Process

1. **Create Model** (`models/feature.model.ts`)
   ```typescript
   import { BaseModel } from "./base.model";
   
   export interface Feature extends BaseModel {
     // properties
   }
   
   export interface CreateFeatureDto {
     // properties
   }
   
   export interface UpdateFeatureDto {
     // optional properties
   }
   ```

2. **Create Service** (`services/feature.service.ts`)
   ```typescript
   import { getDb } from "../db/connection";
   import { Feature, CreateFeatureDto, UpdateFeatureDto } from "../models/feature.model";
   
   class FeatureService {
     async findAll(): Promise<Feature[]> { /* ... */ }
     async findById(id: string | number): Promise<Feature | null> { /* ... */ }
     async create(data: CreateFeatureDto): Promise<Feature> { /* ... */ }
     async update(id: string | number, data: UpdateFeatureDto): Promise<Feature | null> { /* ... */ }
     async delete(id: string | number): Promise<boolean> { /* ... */ }
   }
   
   export const featureService = new FeatureService();
   ```

3. **Create Controller** (`controllers/feature.controller.ts`)
   ```typescript
   import { Elysia } from "elysia";
   import { featureService } from "../services/feature.service";
   import { ResponseView } from "../views/response.view";
   import { CreateFeatureDto, UpdateFeatureDto } from "../models/feature.model";
   
   export const featureController = new Elysia({ prefix: "/features" })
     .get("/", async () => { /* ... */ })
     .get("/:id", async ({ params, set }) => { /* ... */ })
     .post("/", async ({ body, set }) => { /* ... */ })
     .put("/:id", async ({ params, body, set }) => { /* ... */ })
     .delete("/:id", async ({ params, set }) => { /* ... */ });
   ```

4. **Register Routes** (`routes/index.ts`)
   ```typescript
   export const routes = new Elysia({ prefix: appConfig.apiPrefix })
     .use(featureController)
     // ... other controllers
   ```

## Database Best Practices

**DO:**
- Always use parameterized queries (tagged templates or `db.unsafe()` with parameters)
- Map snake_case database columns to camelCase TypeScript properties
- Use transactions for multi-step operations
- Create indexes for frequently queried columns
- Use foreign keys with appropriate CASCADE rules
- Include `created_at` and `updated_at` timestamps (auto-updated via triggers)

**DON'T:**
- Use string concatenation for SQL queries
- Access database directly from controllers
- Skip parameterization in queries

## Type Safety

**DO:**
- Always type function parameters and return values
- Use interfaces for models and DTOs
- Use `unknown` if type is truly unknown
- Leverage TypeScript's type inference where appropriate

**DON'T:**
- Use `any` type
- Omit type annotations
- Use type assertions unnecessarily

## Code Organization

**DO:**
- Keep controllers thin (HTTP concerns only)
- Put business logic in services
- Use models for type safety
- Format responses consistently using views
- Handle errors in middleware
- Keep services independent of HTTP layer

**DON'T:**
- Put business logic in controllers
- Access database from controllers
- Mix concerns between layers

## Testing & Development

**Commands:**
- `bun run dev` - Start development server with hot reload
- `bun run db:migrate` - Run all pending database migrations
- `bun run db:migrate:create <name>` - Create a new migration file

**Default Settings:**
- Server: `http://localhost:3000`
- API endpoints: `/api/v1/*`

## Critical Rules

**NEVER:**
- Modify already-applied migrations
- Use string concatenation for SQL queries
- Access database directly from controllers
- Return raw service responses without `ResponseView`
- Put business logic in controllers

**ALWAYS:**
- Use parameterized queries to prevent SQL injection
- Map database snake_case to TypeScript camelCase
- Use `ResponseView` for API responses
- Set appropriate HTTP status codes
- Validate input in controllers
- Return `null` from services for "not found" cases
- Test database connection on server startup
- Use transactions for multi-step database operations
